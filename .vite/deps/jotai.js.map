{
  "version": 3,
  "sources": ["../../node_modules/.pnpm/jotai@2.8.3_@types+react@18.2.42_react@18.3.1/node_modules/jotai/esm/vanilla.mjs", "../../node_modules/.pnpm/jotai@2.8.3_@types+react@18.2.42_react@18.3.1/node_modules/jotai/esm/react.mjs"],
  "sourcesContent": ["let keyCount = 0;\nfunction atom(read, write) {\n  const key = `atom${++keyCount}`;\n  const config = {\n    toString: () => key\n  };\n  if (typeof read === \"function\") {\n    config.read = read;\n  } else {\n    config.init = read;\n    config.read = defaultRead;\n    config.write = defaultWrite;\n  }\n  if (write) {\n    config.write = write;\n  }\n  return config;\n}\nfunction defaultRead(get) {\n  return get(this);\n}\nfunction defaultWrite(get, set, arg) {\n  return set(\n    this,\n    typeof arg === \"function\" ? arg(get(this)) : arg\n  );\n}\n\nconst isSelfAtom = (atom, a) => atom.unstable_is ? atom.unstable_is(a) : a === atom;\nconst hasInitialValue = (atom) => \"init\" in atom;\nconst isActuallyWritableAtom = (atom) => !!atom.write;\nconst cancelPromiseMap = /* @__PURE__ */ new WeakMap();\nconst registerCancelPromise = (promise, cancel) => {\n  cancelPromiseMap.set(promise, cancel);\n  promise.catch(() => {\n  }).finally(() => cancelPromiseMap.delete(promise));\n};\nconst cancelPromise = (promise, next) => {\n  const cancel = cancelPromiseMap.get(promise);\n  if (cancel) {\n    cancelPromiseMap.delete(promise);\n    cancel(next);\n  }\n};\nconst resolvePromise = (promise, value) => {\n  promise.status = \"fulfilled\";\n  promise.value = value;\n};\nconst rejectPromise = (promise, e) => {\n  promise.status = \"rejected\";\n  promise.reason = e;\n};\nconst isPromiseLike = (x) => typeof (x == null ? void 0 : x.then) === \"function\";\nconst isEqualAtomValue = (a, b) => !!a && \"v\" in a && \"v\" in b && Object.is(a.v, b.v);\nconst isEqualAtomError = (a, b) => !!a && \"e\" in a && \"e\" in b && Object.is(a.e, b.e);\nconst hasPromiseAtomValue = (a) => !!a && \"v\" in a && a.v instanceof Promise;\nconst isEqualPromiseAtomValue = (a, b) => \"v\" in a && \"v\" in b && a.v.orig && a.v.orig === b.v.orig;\nconst returnAtomValue = (atomState) => {\n  if (\"e\" in atomState) {\n    throw atomState.e;\n  }\n  return atomState.v;\n};\nconst createStore$1 = () => {\n  const atomStateMap = /* @__PURE__ */ new WeakMap();\n  const mountedMap = /* @__PURE__ */ new WeakMap();\n  const pendingStack = [];\n  const pendingMap = /* @__PURE__ */ new WeakMap();\n  let devListenersRev2;\n  let mountedAtoms;\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    devListenersRev2 = /* @__PURE__ */ new Set();\n    mountedAtoms = /* @__PURE__ */ new Set();\n  }\n  const getAtomState = (atom) => atomStateMap.get(atom);\n  const addPendingDependent = (atom, atomState) => {\n    atomState.d.forEach((_, a) => {\n      if (!pendingMap.has(a)) {\n        const aState = getAtomState(a);\n        pendingMap.set(a, [aState, /* @__PURE__ */ new Set()]);\n        if (aState) {\n          addPendingDependent(a, aState);\n        }\n      }\n      pendingMap.get(a)[1].add(atom);\n    });\n  };\n  const setAtomState = (atom, atomState) => {\n    var _a;\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      Object.freeze(atomState);\n    }\n    const prevAtomState = getAtomState(atom);\n    atomStateMap.set(atom, atomState);\n    (_a = pendingStack[pendingStack.length - 1]) == null ? void 0 : _a.add(atom);\n    if (!pendingMap.has(atom)) {\n      pendingMap.set(atom, [prevAtomState, /* @__PURE__ */ new Set()]);\n      addPendingDependent(atom, atomState);\n    }\n    if (hasPromiseAtomValue(prevAtomState)) {\n      const next = \"v\" in atomState ? atomState.v instanceof Promise ? atomState.v : Promise.resolve(atomState.v) : Promise.reject(atomState.e);\n      if (prevAtomState.v !== next) {\n        cancelPromise(prevAtomState.v, next);\n      }\n    }\n  };\n  const updateDependencies = (atom, nextAtomState, nextDependencies, keepPreviousDependencies) => {\n    const dependencies = new Map(\n      keepPreviousDependencies ? nextAtomState.d : null\n    );\n    let changed = false;\n    nextDependencies.forEach((aState, a) => {\n      if (!aState && isSelfAtom(atom, a)) {\n        aState = nextAtomState;\n      }\n      if (aState) {\n        dependencies.set(a, aState);\n        if (nextAtomState.d.get(a) !== aState) {\n          changed = true;\n        }\n      } else if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n        console.warn(\"[Bug] atom state not found\");\n      }\n    });\n    if (changed || nextAtomState.d.size !== dependencies.size) {\n      nextAtomState.d = dependencies;\n    }\n  };\n  const setAtomValue = (atom, value, nextDependencies, keepPreviousDependencies) => {\n    const prevAtomState = getAtomState(atom);\n    const nextAtomState = {\n      d: (prevAtomState == null ? void 0 : prevAtomState.d) || /* @__PURE__ */ new Map(),\n      v: value\n    };\n    if (nextDependencies) {\n      updateDependencies(\n        atom,\n        nextAtomState,\n        nextDependencies,\n        keepPreviousDependencies\n      );\n    }\n    if (isEqualAtomValue(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {\n      return prevAtomState;\n    }\n    if (hasPromiseAtomValue(prevAtomState) && hasPromiseAtomValue(nextAtomState) && isEqualPromiseAtomValue(prevAtomState, nextAtomState)) {\n      if (prevAtomState.d === nextAtomState.d) {\n        return prevAtomState;\n      } else {\n        nextAtomState.v = prevAtomState.v;\n      }\n    }\n    setAtomState(atom, nextAtomState);\n    return nextAtomState;\n  };\n  const setAtomValueOrPromise = (atom, valueOrPromise, nextDependencies, abortPromise) => {\n    if (isPromiseLike(valueOrPromise)) {\n      let continuePromise;\n      const updatePromiseDependencies = () => {\n        const prevAtomState = getAtomState(atom);\n        if (!hasPromiseAtomValue(prevAtomState) || prevAtomState.v !== promise) {\n          return;\n        }\n        const nextAtomState = setAtomValue(\n          atom,\n          promise,\n          nextDependencies\n        );\n        if (mountedMap.has(atom) && prevAtomState.d !== nextAtomState.d) {\n          mountDependencies(atom, nextAtomState, prevAtomState.d);\n        }\n      };\n      const promise = new Promise((resolve, reject) => {\n        let settled = false;\n        valueOrPromise.then(\n          (v) => {\n            if (!settled) {\n              settled = true;\n              resolvePromise(promise, v);\n              resolve(v);\n              updatePromiseDependencies();\n            }\n          },\n          (e) => {\n            if (!settled) {\n              settled = true;\n              rejectPromise(promise, e);\n              reject(e);\n              updatePromiseDependencies();\n            }\n          }\n        );\n        continuePromise = (next) => {\n          if (!settled) {\n            settled = true;\n            next.then(\n              (v) => resolvePromise(promise, v),\n              (e) => rejectPromise(promise, e)\n            );\n            resolve(next);\n          }\n        };\n      });\n      promise.orig = valueOrPromise;\n      promise.status = \"pending\";\n      registerCancelPromise(promise, (next) => {\n        if (next) {\n          continuePromise(next);\n        }\n        abortPromise == null ? void 0 : abortPromise();\n      });\n      return setAtomValue(atom, promise, nextDependencies, true);\n    }\n    return setAtomValue(atom, valueOrPromise, nextDependencies);\n  };\n  const setAtomError = (atom, error, nextDependencies) => {\n    const prevAtomState = getAtomState(atom);\n    const nextAtomState = {\n      d: (prevAtomState == null ? void 0 : prevAtomState.d) || /* @__PURE__ */ new Map(),\n      e: error\n    };\n    if (nextDependencies) {\n      updateDependencies(atom, nextAtomState, nextDependencies);\n    }\n    if (isEqualAtomError(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {\n      return prevAtomState;\n    }\n    setAtomState(atom, nextAtomState);\n    return nextAtomState;\n  };\n  const readAtomState = (atom, force) => {\n    const atomState = getAtomState(atom);\n    if (!(force == null ? void 0 : force(atom)) && atomState) {\n      if (mountedMap.has(atom)) {\n        return atomState;\n      }\n      if (Array.from(atomState.d).every(([a, s]) => {\n        if (a === atom) {\n          return true;\n        }\n        const aState = readAtomState(a, force);\n        return aState === s || isEqualAtomValue(aState, s);\n      })) {\n        return atomState;\n      }\n    }\n    const nextDependencies = /* @__PURE__ */ new Map();\n    let isSync = true;\n    const getter = (a) => {\n      if (isSelfAtom(atom, a)) {\n        const aState2 = getAtomState(a);\n        if (aState2) {\n          nextDependencies.set(a, aState2);\n          return returnAtomValue(aState2);\n        }\n        if (hasInitialValue(a)) {\n          nextDependencies.set(a, void 0);\n          return a.init;\n        }\n        throw new Error(\"no atom init\");\n      }\n      const aState = readAtomState(a, force);\n      nextDependencies.set(a, aState);\n      return returnAtomValue(aState);\n    };\n    let controller;\n    let setSelf;\n    const options = {\n      get signal() {\n        if (!controller) {\n          controller = new AbortController();\n        }\n        return controller.signal;\n      },\n      get setSelf() {\n        if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !isActuallyWritableAtom(atom)) {\n          console.warn(\"setSelf function cannot be used with read-only atom\");\n        }\n        if (!setSelf && isActuallyWritableAtom(atom)) {\n          setSelf = (...args) => {\n            if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && isSync) {\n              console.warn(\"setSelf function cannot be called in sync\");\n            }\n            if (!isSync) {\n              return writeAtom(atom, ...args);\n            }\n          };\n        }\n        return setSelf;\n      }\n    };\n    try {\n      const valueOrPromise = atom.read(getter, options);\n      return setAtomValueOrPromise(\n        atom,\n        valueOrPromise,\n        nextDependencies,\n        () => controller == null ? void 0 : controller.abort()\n      );\n    } catch (error) {\n      return setAtomError(atom, error, nextDependencies);\n    } finally {\n      isSync = false;\n    }\n  };\n  const readAtom = (atom) => returnAtomValue(readAtomState(atom));\n  const recomputeDependents = (atom) => {\n    const getDependents = (a) => {\n      var _a, _b;\n      const dependents = new Set((_a = mountedMap.get(a)) == null ? void 0 : _a.t);\n      (_b = pendingMap.get(a)) == null ? void 0 : _b[1].forEach((dependent) => {\n        dependents.add(dependent);\n      });\n      return dependents;\n    };\n    const topsortedAtoms = new Array();\n    const markedAtoms = /* @__PURE__ */ new Set();\n    const visit = (n) => {\n      if (markedAtoms.has(n)) {\n        return;\n      }\n      markedAtoms.add(n);\n      for (const m of getDependents(n)) {\n        if (n !== m) {\n          visit(m);\n        }\n      }\n      topsortedAtoms.push(n);\n    };\n    visit(atom);\n    const changedAtoms = /* @__PURE__ */ new Set([atom]);\n    const isMarked = (a) => markedAtoms.has(a);\n    for (let i = topsortedAtoms.length - 1; i >= 0; --i) {\n      const a = topsortedAtoms[i];\n      const prevAtomState = getAtomState(a);\n      if (!prevAtomState) {\n        continue;\n      }\n      let hasChangedDeps = false;\n      for (const dep of prevAtomState.d.keys()) {\n        if (dep !== a && changedAtoms.has(dep)) {\n          hasChangedDeps = true;\n          break;\n        }\n      }\n      if (hasChangedDeps) {\n        const nextAtomState = readAtomState(a, isMarked);\n        addPendingDependent(a, nextAtomState);\n        if (!isEqualAtomValue(prevAtomState, nextAtomState)) {\n          changedAtoms.add(a);\n        }\n      }\n      markedAtoms.delete(a);\n    }\n  };\n  const writeAtomState = (atom, ...args) => {\n    const getter = (a) => returnAtomValue(readAtomState(a));\n    const setter = (a, ...args2) => {\n      const isSync = pendingStack.length > 0;\n      if (!isSync) {\n        pendingStack.push(/* @__PURE__ */ new Set([a]));\n      }\n      let r;\n      if (isSelfAtom(atom, a)) {\n        if (!hasInitialValue(a)) {\n          throw new Error(\"atom not writable\");\n        }\n        const prevAtomState = getAtomState(a);\n        const nextAtomState = setAtomValueOrPromise(a, args2[0]);\n        if (!isEqualAtomValue(prevAtomState, nextAtomState)) {\n          recomputeDependents(a);\n        }\n      } else {\n        r = writeAtomState(a, ...args2);\n      }\n      if (!isSync) {\n        const flushed = flushPending(pendingStack.pop());\n        if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n          devListenersRev2.forEach(\n            (l) => l({ type: \"async-write\", flushed })\n          );\n        }\n      }\n      return r;\n    };\n    const result = atom.write(getter, setter, ...args);\n    return result;\n  };\n  const writeAtom = (atom, ...args) => {\n    pendingStack.push(/* @__PURE__ */ new Set([atom]));\n    const result = writeAtomState(atom, ...args);\n    const flushed = flushPending(pendingStack.pop());\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      devListenersRev2.forEach((l) => l({ type: \"write\", flushed }));\n    }\n    return result;\n  };\n  const mountAtom = (atom, initialDependent, onMountQueue) => {\n    var _a;\n    const existingMount = mountedMap.get(atom);\n    if (existingMount) {\n      if (initialDependent) {\n        existingMount.t.add(initialDependent);\n      }\n      return existingMount;\n    }\n    const queue = onMountQueue || [];\n    (_a = getAtomState(atom)) == null ? void 0 : _a.d.forEach((_, a) => {\n      if (a !== atom) {\n        mountAtom(a, atom, queue);\n      }\n    });\n    readAtomState(atom);\n    const mounted = {\n      t: new Set(initialDependent && [initialDependent]),\n      l: /* @__PURE__ */ new Set()\n    };\n    mountedMap.set(atom, mounted);\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      mountedAtoms.add(atom);\n    }\n    if (isActuallyWritableAtom(atom) && atom.onMount) {\n      const { onMount } = atom;\n      queue.push(() => {\n        const onUnmount = onMount((...args) => writeAtom(atom, ...args));\n        if (onUnmount) {\n          mounted.u = onUnmount;\n        }\n      });\n    }\n    if (!onMountQueue) {\n      queue.forEach((f) => f());\n    }\n    return mounted;\n  };\n  const canUnmountAtom = (atom, mounted) => !mounted.l.size && (!mounted.t.size || mounted.t.size === 1 && mounted.t.has(atom));\n  const tryUnmountAtom = (atom, mounted) => {\n    if (!canUnmountAtom(atom, mounted)) {\n      return;\n    }\n    const onUnmount = mounted.u;\n    if (onUnmount) {\n      onUnmount();\n    }\n    mountedMap.delete(atom);\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      mountedAtoms.delete(atom);\n    }\n    const atomState = getAtomState(atom);\n    if (atomState) {\n      if (hasPromiseAtomValue(atomState)) {\n        cancelPromise(atomState.v);\n      }\n      atomState.d.forEach((_, a) => {\n        if (a !== atom) {\n          const mountedDep = mountedMap.get(a);\n          if (mountedDep) {\n            mountedDep.t.delete(atom);\n            tryUnmountAtom(a, mountedDep);\n          }\n        }\n      });\n    } else if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      console.warn(\"[Bug] could not find atom state to unmount\", atom);\n    }\n  };\n  const mountDependencies = (atom, atomState, prevDependencies) => {\n    const depSet = new Set(atomState.d.keys());\n    const maybeUnmountAtomSet = /* @__PURE__ */ new Set();\n    prevDependencies == null ? void 0 : prevDependencies.forEach((_, a) => {\n      if (depSet.has(a)) {\n        depSet.delete(a);\n        return;\n      }\n      maybeUnmountAtomSet.add(a);\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.delete(atom);\n      }\n    });\n    depSet.forEach((a) => {\n      mountAtom(a, atom);\n    });\n    maybeUnmountAtomSet.forEach((a) => {\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        tryUnmountAtom(a, mounted);\n      }\n    });\n  };\n  const flushPending = (pendingAtoms) => {\n    let flushed;\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      flushed = /* @__PURE__ */ new Set();\n    }\n    const pending = [];\n    const collectPending = (pendingAtom) => {\n      var _a;\n      if (!pendingMap.has(pendingAtom)) {\n        return;\n      }\n      const [prevAtomState, dependents] = pendingMap.get(pendingAtom);\n      pendingMap.delete(pendingAtom);\n      pending.push([pendingAtom, prevAtomState]);\n      dependents.forEach(collectPending);\n      (_a = getAtomState(pendingAtom)) == null ? void 0 : _a.d.forEach((_, a) => collectPending(a));\n    };\n    pendingAtoms.forEach(collectPending);\n    pending.forEach(([atom, prevAtomState]) => {\n      const atomState = getAtomState(atom);\n      if (!atomState) {\n        if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n          console.warn(\"[Bug] no atom state to flush\");\n        }\n        return;\n      }\n      if (atomState !== prevAtomState) {\n        const mounted = mountedMap.get(atom);\n        if (mounted && atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n          mountDependencies(atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n        }\n        if (mounted && !// TODO This seems pretty hacky. Hope to fix it.\n        // Maybe we could `mountDependencies` in `setAtomState`?\n        (!hasPromiseAtomValue(prevAtomState) && (isEqualAtomValue(prevAtomState, atomState) || isEqualAtomError(prevAtomState, atomState)))) {\n          mounted.l.forEach((listener) => listener());\n          if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n            flushed.add(atom);\n          }\n        }\n      }\n    });\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      return flushed;\n    }\n  };\n  const subscribeAtom = (atom, listener) => {\n    const mounted = mountAtom(atom);\n    const flushed = flushPending([atom]);\n    const listeners = mounted.l;\n    listeners.add(listener);\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      devListenersRev2.forEach(\n        (l) => l({ type: \"sub\", flushed })\n      );\n    }\n    return () => {\n      listeners.delete(listener);\n      tryUnmountAtom(atom, mounted);\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n        devListenersRev2.forEach((l) => l({ type: \"unsub\" }));\n      }\n    };\n  };\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    return {\n      get: readAtom,\n      set: writeAtom,\n      sub: subscribeAtom,\n      // store dev methods (these are tentative and subject to change without notice)\n      dev_subscribe_store: (l) => {\n        devListenersRev2.add(l);\n        return () => {\n          devListenersRev2.delete(l);\n        };\n      },\n      dev_get_mounted_atoms: () => mountedAtoms.values(),\n      dev_get_atom_state: (a) => atomStateMap.get(a),\n      dev_get_mounted: (a) => mountedMap.get(a),\n      dev_restore_atoms: (values) => {\n        pendingStack.push(/* @__PURE__ */ new Set());\n        for (const [atom, valueOrPromise] of values) {\n          if (hasInitialValue(atom)) {\n            setAtomValueOrPromise(atom, valueOrPromise);\n            recomputeDependents(atom);\n          }\n        }\n        const flushed = flushPending(pendingStack.pop());\n        devListenersRev2.forEach(\n          (l) => l({ type: \"restore\", flushed })\n        );\n      }\n    };\n  }\n  return {\n    get: readAtom,\n    set: writeAtom,\n    sub: subscribeAtom\n  };\n};\nlet defaultStore;\nconst getDefaultStore$1 = () => {\n  if (!defaultStore) {\n    defaultStore = createStore$1();\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      globalThis.__JOTAI_DEFAULT_STORE__ || (globalThis.__JOTAI_DEFAULT_STORE__ = defaultStore);\n      if (globalThis.__JOTAI_DEFAULT_STORE__ !== defaultStore) {\n        console.warn(\n          \"Detected multiple Jotai instances. It may cause unexpected behavior with the default store. https://github.com/pmndrs/jotai/discussions/2044\"\n        );\n      }\n    }\n  }\n  return defaultStore;\n};\n\nSymbol(\n  (import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" ? \"CONTINUE_PROMISE\" : \"\"\n);\n\nconst createStore = createStore$1;\nconst getDefaultStore = getDefaultStore$1;\n\nexport { atom, createStore, getDefaultStore };\n", "'use client';\nimport ReactExports, { createContext, useContext, useRef, createElement, useReducer, useEffect, useDebugValue, useCallback } from 'react';\nimport { getDefaultStore, createStore } from 'jotai/vanilla';\n\nconst StoreContext = createContext(\n  void 0\n);\nconst useStore = (options) => {\n  const store = useContext(StoreContext);\n  return (options == null ? void 0 : options.store) || store || getDefaultStore();\n};\nconst Provider = ({\n  children,\n  store\n}) => {\n  const storeRef = useRef();\n  if (!store && !storeRef.current) {\n    storeRef.current = createStore();\n  }\n  return createElement(\n    StoreContext.Provider,\n    {\n      value: store || storeRef.current\n    },\n    children\n  );\n};\n\nconst isPromiseLike = (x) => typeof (x == null ? void 0 : x.then) === \"function\";\nconst use = ReactExports.use || ((promise) => {\n  if (promise.status === \"pending\") {\n    throw promise;\n  } else if (promise.status === \"fulfilled\") {\n    return promise.value;\n  } else if (promise.status === \"rejected\") {\n    throw promise.reason;\n  } else {\n    promise.status = \"pending\";\n    promise.then(\n      (v) => {\n        promise.status = \"fulfilled\";\n        promise.value = v;\n      },\n      (e) => {\n        promise.status = \"rejected\";\n        promise.reason = e;\n      }\n    );\n    throw promise;\n  }\n});\nfunction useAtomValue(atom, options) {\n  const store = useStore(options);\n  const [[valueFromReducer, storeFromReducer, atomFromReducer], rerender] = useReducer(\n    (prev) => {\n      const nextValue = store.get(atom);\n      if (Object.is(prev[0], nextValue) && prev[1] === store && prev[2] === atom) {\n        return prev;\n      }\n      return [nextValue, store, atom];\n    },\n    void 0,\n    () => [store.get(atom), store, atom]\n  );\n  let value = valueFromReducer;\n  if (storeFromReducer !== store || atomFromReducer !== atom) {\n    rerender();\n    value = store.get(atom);\n  }\n  const delay = options == null ? void 0 : options.delay;\n  useEffect(() => {\n    const unsub = store.sub(atom, () => {\n      if (typeof delay === \"number\") {\n        setTimeout(rerender, delay);\n        return;\n      }\n      rerender();\n    });\n    rerender();\n    return unsub;\n  }, [store, atom, delay]);\n  useDebugValue(value);\n  return isPromiseLike(value) ? use(value) : value;\n}\n\nfunction useSetAtom(atom, options) {\n  const store = useStore(options);\n  const setAtom = useCallback(\n    (...args) => {\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !(\"write\" in atom)) {\n        throw new Error(\"not writable atom\");\n      }\n      return store.set(atom, ...args);\n    },\n    [store, atom]\n  );\n  return setAtom;\n}\n\nfunction useAtom(atom, options) {\n  return [\n    useAtomValue(atom, options),\n    // We do wrong type assertion here, which results in throwing an error.\n    useSetAtom(atom, options)\n  ];\n}\n\nexport { Provider, useAtom, useAtomValue, useSetAtom, useStore };\n"],
  "mappings": "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",
  "names": ["atom", "isPromiseLike", "ReactExports", "atom"]
}
